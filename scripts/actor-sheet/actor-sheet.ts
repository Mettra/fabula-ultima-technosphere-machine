import { Log, ModuleName, getItemDisplayData } from "../core-config";
import { Relations } from "../relation";
import { recomputeTechnosphereSheet } from "../technosphere-recompute";

// Helper functions for Mnemosphere equipment management
function getEquippedMnemospheres(actor: any): string[] {
    return actor.getFlag(ModuleName, "equipped-mnemospheres") || [];
}

function setEquippedMnemospheres(
    actor: any,
    equippedList: string[]
): Promise<any> {
    return actor.setFlag(ModuleName, "equipped-mnemospheres", equippedList);
}

function isMnemosphereEquipped(actor: any, itemUuid: string): boolean {
    const equipped = getEquippedMnemospheres(actor);
    return equipped.includes(itemUuid);
}

async function toggleMnemosphereEquipped(
    actor: any,
    itemUuid: string
): Promise<void> {
    const equipped = getEquippedMnemospheres(actor);
    const isCurrentlyEquipped = equipped.includes(itemUuid);

    let newEquipped: string[];
    if (isCurrentlyEquipped) {
        // Unequip - remove from list
        newEquipped = equipped.filter((uuid) => uuid !== itemUuid);
    } else {
        // Equip - add to list
        newEquipped = [...equipped, itemUuid];
    }

    await setEquippedMnemospheres(actor, newEquipped);

    // The mnemosphere core hooks will automatically trigger the update
    Log(
        `Mnemosphere ${
            isCurrentlyEquipped ? "unequipped" : "equipped"
        } for actor ${actor.name}`
    );
}

async function addMnemosphereSourceIcons(html: any, actor: any) {
    // Find all items that are generated by mnemospheres
    const generatedItems = Array.from(actor.items).filter((item: any) =>
        item.getFlag(ModuleName, "generated-by-mnemosphere")
    );

    for (const item of generatedItems) {
        const itemAny = item as any;
        const sourceUuids = itemAny.getFlag(ModuleName, "mnemosphere-sources");

        // Find the item row in the HTML
        const itemRow = html.find(`li[data-item-id="${itemAny.id}"]`);
        if (itemRow.length === 0) continue;

        // Grey out skill buttons for mnemo skills
        greyOutMnemoSkillButtons(itemRow, itemAny);

        if (!sourceUuids || sourceUuids.length === 0) continue;

        // Get source mnemosphere items
        const sourceMnemospheres = [];
        for (const uuid of sourceUuids) {
            try {
                const sourceItem = await fromUuid(uuid as UUID);
                if (sourceItem) {
                    const sourceItemAny = sourceItem as any;
                    sourceMnemospheres.push({
                        uuid: uuid,
                        name: sourceItemAny.name,
                        img: sourceItemAny.img,
                        item: sourceItemAny,
                    });
                }
            } catch (error) {
                Log(`Failed to resolve source mnemosphere ${uuid}:`, error);
            }
        }

        if (sourceMnemospheres.length === 0) continue;

        // Create the source icons HTML
        const iconsHtml = sourceMnemospheres
            .map(
                (source) => `
            <img src="${source.img}"
                 class="mnemosphere-source-icon" 
                 data-uuid="${source.uuid}"
                 style="width: 24px; height: 24px; margin-left: 2px; cursor: pointer; border-radius: 2px;">
        `
            )
            .join("");

        // Add the icons to the item name section
        const itemNameDiv = itemRow.find(".item-name");
        if (itemNameDiv.length > 0) {
            itemNameDiv.append(
                `<span class="mnemosphere-sources">${iconsHtml}</span>`
            );
        }
    }

    // Set up hover handlers for mnemosphere source icons
    html.find(".mnemosphere-source-icon").hover(
        function (event) {
            const uuid = $(this).data("uuid");
            showMnemosphereCard(event, uuid);
        },
        function () {
            hideMnemosphereCard();
        }
    );
}

let currentMnemosphereCard: any = null;

async function showMnemosphereCard(event: any, uuid: string) {
    try {
        const mnemosphere = await fromUuid(uuid as UUID);
        if (!mnemosphere) return;
        const mnemosphereAny = mnemosphere as any;

        // Remove any existing card
        hideMnemosphereCard();

        // Create a card similar to item tooltips
        const cardHtml = `
            <div class="mnemosphere-hover-card" style="
                position: absolute;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #444;
                border-radius: 4px;
                padding: 8px;
                color: white;
                max-width: 300px;
                z-index: 1000;
                font-size: 18px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            ">
                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                    <strong>${mnemosphereAny.name}</strong>
                </div>
            </div>
        `;

        const $card = $(cardHtml);
        $("body").append($card);
        currentMnemosphereCard = $card;

        // Position the card near the cursor
        const mouseX = event.pageX || event.originalEvent.pageX;
        const mouseY = event.pageY || event.originalEvent.pageY;

        $card.css({
            left: mouseX + 10,
            top: mouseY - 10,
        });

        // Adjust position if card would go off screen
        const cardWidth = $card.outerWidth();
        const cardHeight = $card.outerHeight();
        const windowWidth = $(window).width();
        const windowHeight = $(window).height();

        if (mouseX + cardWidth + 10 > windowWidth) {
            $card.css("left", mouseX - cardWidth - 10);
        }
        if (mouseY + cardHeight > windowHeight) {
            $card.css("top", mouseY - cardHeight - 10);
        }
    } catch (error) {
        Log(`Failed to show mnemosphere card for ${uuid}:`, error);
    }
}

function hideMnemosphereCard() {
    if (currentMnemosphereCard) {
        currentMnemosphereCard.remove();
        currentMnemosphereCard = null;
    }
}

/**
 * Greys out skill level buttons for items generated by mnemosphere
 * @param itemRow - The jQuery element representing the item row
 * @param item - The item object that was generated by mnemosphere
 */
function greyOutMnemoSkillButtons(itemRow: any, item: any): void {
    // Find skill level controls (star buttons) in this item row
    const skillLevelInputs = itemRow.find(".skillLevel input");
    const skillLevelContainers = itemRow.find(".skillLevel");

    // Apply greyed out styles to skill level star buttons
    skillLevelInputs.each(function () {
        const input = $(this);
        input.addClass("mnemo-skill-disabled");

        // Add tooltip explaining why it's disabled
        input.attr("title", "Mnemo skill levels cannot be modified directly");
    });

    // Apply greyed out styles to skill level containers (to prevent right-click reset)
    skillLevelContainers.each(function () {
        const container = $(this);
        container.addClass("mnemo-skill-disabled");

        // Add tooltip explaining why it's disabled
        container.attr(
            "title",
            "Mnemo skill levels cannot be modified directly"
        );
    });
}

export function SetupActorSheetHooks() {
    Hooks.on(`renderFUStandardActorSheet`, async (sheet: any, html: any) => {
        // Get all treasure items and separate Mnemospheres from regular treasures
        const actor = sheet.object;
        const allTreasures = Array.from(actor.items).filter(
            (item: any) => item.type === "treasure"
        );
        const mnemospheres: any[] = [];
        const regularTreasures: any[] = [];

        allTreasures.forEach((treasure) => {
            const itemAny = treasure as any;
            const mnemosphereId = Relations.Item.mnemosphere.check(
                itemAny.uuid as UUID
            );
            if (mnemosphereId) {
                // This is a Mnemosphere - create a proper object with the necessary properties
                const isEquipped = isMnemosphereEquipped(actor, itemAny.uuid);
                const itemData = getItemDisplayData(itemAny);
                mnemospheres.push({
                    _id: itemAny._id,
                    uuid: itemAny.uuid,
                    name: itemAny.name,
                    img: itemAny.img,
                    type: itemAny.type,
                    system: itemAny.system,
                    quality: itemData ? itemData.qualityString : "",
                    enrichedHtml: itemAny.enrichedHtml,
                    isEquipped: isEquipped,
                });
            } else {
                // Regular treasure
                regularTreasures.push(itemAny);
            }
        });

        // Remove Mnemospheres from the existing treasure list
        const treasureSection = html
            .find('.tab[data-tab="items"] ol.items-list')
            .has('li .item-name:contains("Treasures")');
        if (treasureSection.length > 0) {
            // Remove Mnemosphere items from treasure section
            mnemospheres.forEach((mnemosphere) => {
                treasureSection
                    .find(`li[data-item-id="${mnemosphere._id}"]`)
                    .remove();
            });
        }

        // Add Mnemosphere section if there are any Mnemospheres
        if (mnemospheres.length > 0) {
            const mnemosphereSection = await renderTemplate(
                "modules/fabula-ultima-technosphere-machine/templates/inject/actor-sheet/mnemosphere-section.hbs",
                {
                    mnemospheres: mnemospheres,
                    actor: actor,
                    _expandedIds: sheet._expandedIds || [],
                }
            );

            // Insert the Mnemosphere section after the treasure section
            if (treasureSection.length > 0) {
                treasureSection.after(mnemosphereSection);
            } else {
                // If no treasure section exists, add it to the items tab
                const itemsTab = html.find('.tab[data-tab="items"]');
                itemsTab.append(mnemosphereSection);
            }
        }

        // Add mnemosphere source icons to generated items
        await addMnemosphereSourceIcons(html, actor);

        // Handle Mnemosphere equip/unequip button clicks
        html.find(".mnemosphere-equip-toggle")
            .unbind("click")
            .bind("click", async (event) => {
                event.preventDefault();
                event.stopPropagation();

                const button = $(event.currentTarget);
                const itemUuid = button.data("item-uuid");

                try {
                    await toggleMnemosphereEquipped(actor, itemUuid); // Update icon appearance to match standard equip pattern
                    const isNowEquipped = isMnemosphereEquipped(
                        actor,
                        itemUuid
                    );
                    const icon = button.find("i");
                    const tooltipText = isNowEquipped
                        ? "Unequip Mnemosphere"
                        : "Equip Mnemosphere";

                    button.attr("data-tooltip", tooltipText);

                    if (isNowEquipped) {
                        icon.removeClass("far").addClass("fas");
                    } else {
                        icon.removeClass("fas").addClass("far");
                    }
                } catch (error) {
                    console.error(
                        "Error toggling Mnemosphere equipment:",
                        error
                    );
                }
            });

        // Handle Apply Technosphere button
        html.find(".technosphere-apply")
            .unbind("click")
            .bind("click", async (event) => {
                event.target.disabled = true;
                try {
                    const baseSheetActor = fromUuidSync(
                        sheet.document.getFlag(ModuleName, "base-sheet-uuid")
                    );
                    if (!baseSheetActor) {
                        ui.notifications.error(
                            "Invalid Base Sheet UUID. Please ensure the UUID refers to an existing Actor."
                        );
                        return;
                    }
                    const currentActor = sheet.object;
                    await recomputeTechnosphereSheet(
                        currentActor,
                        baseSheetActor
                    );
                    ui.notifications.info(
                        `Technosphere recomputation applied to ${currentActor.name}.`
                    );
                } catch (error) {
                    console.error(
                        "Error applying Technosphere recomputation:",
                        error
                    );
                    ui.notifications.error(
                        "An error occurred during Technosphere recomputation. Check console for details."
                    );
                } finally {
                    event.target.disabled = false;
                    Log("Technosphere recomputation process finished.");
                }
            });
    });
}
